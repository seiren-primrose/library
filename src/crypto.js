const nodeCrypto=require("crypto"),assert=require("assert");function assertBuffer(a){if(!(a instanceof Buffer))throw TypeError(`Expected Buffer instead of: ${a.constructor.name}`);return a}function encrypt(a,b,c){assertBuffer(a);assertBuffer(b);assertBuffer(c);a=nodeCrypto.createCipheriv("aes-256-cbc",a,c);return Buffer.concat([a.update(b),a.final()])}
function decrypt(a,b,c){assertBuffer(a);assertBuffer(b);assertBuffer(c);a=nodeCrypto.createDecipheriv("aes-256-cbc",a,c);return Buffer.concat([a.update(b),a.final()])}function calculateMAC(a,b){assertBuffer(a);assertBuffer(b);a=nodeCrypto.createHmac("sha256",a);a.update(b);return Buffer.from(a.digest())}function hash(a){assertBuffer(a);const b=nodeCrypto.createHash("sha512");b.update(a);return b.digest()}
function deriveSecrets(a,b,c,d){assertBuffer(a);assertBuffer(b);assertBuffer(c);if(32!=b.byteLength)throw Error("Got salt of incorrect length");d=d||3;assert(1<=d&&3>=d);a=calculateMAC(b,a);b=new Uint8Array(c.byteLength+1+32);b.set(c,32);b[b.length-1]=1;c=[calculateMAC(a,Buffer.from(b.slice(32)))];1<d&&(b.set(c[c.length-1]),b[b.length-1]=2,c.push(calculateMAC(a,Buffer.from(b))));2<d&&(b.set(c[c.length-1]),b[b.length-1]=3,c.push(calculateMAC(a,Buffer.from(b))));return c}
function verifyMAC(a,b,c,d){a=calculateMAC(b,a).slice(0,d);if(c.length!==d||a.length!==d)throw Error("Bad MAC length");if(!c.equals(a))throw Error("Bad MAC");}module.exports={deriveSecrets,decrypt,encrypt,hash,calculateMAC,verifyMAC};
