const BaseKeyType=require("./base_key_type"),CLOSED_SESSIONS_MAX=40,SESSION_RECORD_VERSION="v1";function assertBuffer(a){if(!Buffer.isBuffer(a))throw new TypeError("Buffer required");}
class SessionEntry{constructor(){this._chains={}}toString(){return`<SessionEntry [baseKey=${this.indexInfo&&this.indexInfo.baseKey&&this.indexInfo.baseKey.toString("base64")}]>`}inspect(){return this.toString()}addChain(a,b){assertBuffer(a);a=a.toString("base64");if(this._chains.hasOwnProperty(a))throw Error("Overwrite attempt");this._chains[a]=b}getChain(a){assertBuffer(a);return this._chains[a.toString("base64")]}deleteChain(a){assertBuffer(a);a=a.toString("base64");if(!this._chains.hasOwnProperty(a))throw new ReferenceError("Not Found");
delete this._chains[a]}*chains(){for(const [a,b]of Object.entries(this._chains))yield[Buffer.from(a,"base64"),b]}serialize(){const a={registrationId:this.registrationId,currentRatchet:{ephemeralKeyPair:{pubKey:this.currentRatchet.ephemeralKeyPair.pubKey.toString("base64"),privKey:this.currentRatchet.ephemeralKeyPair.privKey.toString("base64")},lastRemoteEphemeralKey:this.currentRatchet.lastRemoteEphemeralKey.toString("base64"),previousCounter:this.currentRatchet.previousCounter,rootKey:this.currentRatchet.rootKey.toString("base64")},
indexInfo:{baseKey:this.indexInfo.baseKey.toString("base64"),baseKeyType:this.indexInfo.baseKeyType,closed:this.indexInfo.closed,used:this.indexInfo.used,created:this.indexInfo.created,remoteIdentityKey:this.indexInfo.remoteIdentityKey.toString("base64")},_chains:this._serialize_chains(this._chains)};this.pendingPreKey&&(a.pendingPreKey=Object.assign({},this.pendingPreKey),a.pendingPreKey.baseKey=this.pendingPreKey.baseKey.toString("base64"));return a}static deserialize(a){const b=new this;b.registrationId=
a.registrationId;b.currentRatchet={ephemeralKeyPair:{pubKey:Buffer.from(a.currentRatchet.ephemeralKeyPair.pubKey,"base64"),privKey:Buffer.from(a.currentRatchet.ephemeralKeyPair.privKey,"base64")},lastRemoteEphemeralKey:Buffer.from(a.currentRatchet.lastRemoteEphemeralKey,"base64"),previousCounter:a.currentRatchet.previousCounter,rootKey:Buffer.from(a.currentRatchet.rootKey,"base64")};b.indexInfo={baseKey:Buffer.from(a.indexInfo.baseKey,"base64"),baseKeyType:a.indexInfo.baseKeyType,closed:a.indexInfo.closed,
used:a.indexInfo.used,created:a.indexInfo.created,remoteIdentityKey:Buffer.from(a.indexInfo.remoteIdentityKey,"base64")};b._chains=this._deserialize_chains(a._chains);a.pendingPreKey&&(b.pendingPreKey=Object.assign({},a.pendingPreKey),b.pendingPreKey.baseKey=Buffer.from(a.pendingPreKey.baseKey,"base64"));return b}_serialize_chains(a){const b={};for(const c of Object.keys(a)){const d=a[c],e={};for(const [f,g]of Object.entries(d.messageKeys))e[f]=g.toString("base64");b[c]={chainKey:{counter:d.chainKey.counter,
key:d.chainKey.key&&d.chainKey.key.toString("base64")},chainType:d.chainType,messageKeys:e}}return b}static _deserialize_chains(a){const b={};for(const c of Object.keys(a)){const d=a[c],e={};for(const [f,g]of Object.entries(d.messageKeys))e[f]=Buffer.from(g,"base64");b[c]={chainKey:{counter:d.chainKey.counter,key:d.chainKey.key&&Buffer.from(d.chainKey.key,"base64")},chainType:d.chainType,messageKeys:e}}return b}}
const migrations=[{version:"v1",migrate:function(a){const b=a._sessions;if(a.registrationId)for(const c in b)b[c].registrationId||(b[c].registrationId=a.registrationId);else for(const c in b)-1===b[c].indexInfo.closed&&console.error("V1 session storage migration error: registrationId",a.registrationId,"for open session version",a.version)}}];
class SessionRecord{static createEntry(){return new SessionEntry}static migrate(a){let b=void 0===a.version;for(let c=0;c<migrations.length;++c)b?(console.info("Migrating session to:",migrations[c].version),migrations[c].migrate(a)):migrations[c].version===a.version&&(b=!0);if(!b)throw Error("Error migrating SessionRecord");}static deserialize(a){a.version!==SESSION_RECORD_VERSION&&this.migrate(a);const b=new this;if(a._sessions)for(const [c,d]of Object.entries(a._sessions))b.sessions[c]=SessionEntry.deserialize(d);
return b}constructor(){this.sessions={};this.version=SESSION_RECORD_VERSION}serialize(){const a={};for(const [b,c]of Object.entries(this.sessions))a[b]=c.serialize();return{_sessions:a,version:this.version}}haveOpenSession(){const a=this.getOpenSession();return!!a&&"number"===typeof a.registrationId}getSession(a){assertBuffer(a);if((a=this.sessions[a.toString("base64")])&&a.indexInfo.baseKeyType===BaseKeyType.OURS)throw Error("Tried to lookup a session using our basekey");return a}getOpenSession(){for(const a of Object.values(this.sessions))if(!this.isClosed(a))return a}setSession(a){this.sessions[a.indexInfo.baseKey.toString("base64")]=
a}getSessions(){return Array.from(Object.values(this.sessions)).sort((a,b)=>{a=a.indexInfo.used||0;b=b.indexInfo.used||0;return a===b?0:a<b?1:-1})}closeSession(a){this.isClosed(a)||(a.indexInfo.closed=Date.now())}openSession(a){this.isClosed(a)||console.warn("Session already open");a.indexInfo.closed=-1}isClosed(a){return-1!==a.indexInfo.closed}removeOldSessions(){for(;Object.keys(this.sessions).length>CLOSED_SESSIONS_MAX;){let a,b;for(const [c,d]of Object.entries(this.sessions))-1!==
d.indexInfo.closed&&(!b||d.indexInfo.closed<b.indexInfo.closed)&&(a=c,b=d);if(a)delete this.sessions[a];else throw Error("Corrupt sessions object");}}deleteAllSessions(){for(const a of Object.keys(this.sessions))delete this.sessions[a]}}module.exports=SessionRecord;
