const BaseKeyType=require("./base_key_type"),ChainType=require("./chain_type"),SessionRecord=require("./session_record"),cryptoS=require("./crypto"),curve=require("./curve"),errors=require("./errors"),queueJob=require("./queue_job");
class SessionBuilder{constructor(a,b){this.addr=b;this.storage=a}async initOutgoing(a){const b=this.addr.toString();return await queueJob(b,async()=>{if(!await this.storage.isTrustedIdentity(this.addr.id,a.identityKey))throw new errors.UntrustedIdentityKeyError(this.addr.id,a.identityKey);curve.verifySignature(a.identityKey,a.signedPreKey.publicKey,a.signedPreKey.signature,!0);var c=curve.generateKeyPair();const g=await this.initSession(!0,c,void 0,a.identityKey,a.preKey&&a.preKey.publicKey,a.signedPreKey.publicKey,
a.registrationId);g.pendingPreKey={signedKeyId:a.signedPreKey.keyId,baseKey:c.pubKey};a.preKey&&(g.pendingPreKey.preKeyId=a.preKey.keyId);if(c=await this.storage.loadSession(b)){const e=c.getOpenSession();e&&c.closeSession(e)}else c=new SessionRecord;c.setSession(g);await this.storage.storeSession(b,c)})}async initIncoming(a,b){if(!await this.storage.isTrustedIdentity(this.addr.toString(),b.identityKey))throw new errors.UntrustedIdentityKeyError(this.addr.id,b.identityKey);if(!a.getSession(b.baseKey)){var c=
await this.storage.loadPreKey(b.preKeyId);if(b.preKeyId&&!c)throw new errors.PreKeyError("Invalid PreKey ID");var g=await this.storage.loadSignedPreKey(b.signedPreKeyId);if(!g)throw new errors.PreKeyError("Missing SignedPreKey");var e=a.getOpenSession();e&&a.closeSession(e);a.setSession(await this.initSession(!1,c,g,b.identityKey,b.baseKey,void 0,b.registrationId));return b.preKeyId}}async initSession(a,b,c,g,e,h,l){if(a){if(c)throw Error("Invalid call to initSession");c=b}else{if(h)throw Error("Invalid call to initSession");
h=e}for(var f=b&&e?new Uint8Array(160):new Uint8Array(128),d=0;32>d;d++)f[d]=255;d=await this.storage.getOurIdentity();d=curve.calculateAgreement(h,d.privKey);const k=curve.calculateAgreement(g,c.privKey),m=curve.calculateAgreement(h,c.privKey);a?(f.set(new Uint8Array(d),32),f.set(new Uint8Array(k),64)):(f.set(new Uint8Array(d),64),f.set(new Uint8Array(k),32));f.set(new Uint8Array(m),96);b&&e&&(d=curve.calculateAgreement(e,b.privKey),f.set(new Uint8Array(d),128));f=cryptoS.deriveSecrets(Buffer.from(f),
Buffer.alloc(32),Buffer.from("WhisperText"));d=SessionRecord.createEntry();d.registrationId=l;d.currentRatchet={rootKey:f[0],ephemeralKeyPair:a?curve.generateKeyPair():c,lastRemoteEphemeralKey:h,previousCounter:0};d.indexInfo={created:Date.now(),used:Date.now(),remoteIdentityKey:g,baseKey:a?b.pubKey:e,baseKeyType:a?BaseKeyType.OURS:BaseKeyType.THEIRS,closed:-1};a&&this.calculateSendingRatchet(d,h);return d}calculateSendingRatchet(a,b){const c=a.currentRatchet;b=curve.calculateAgreement(b,c.ephemeralKeyPair.privKey);
b=cryptoS.deriveSecrets(b,c.rootKey,Buffer.from("WhisperRatchet"));a.addChain(c.ephemeralKeyPair.pubKey,{messageKeys:{},chainKey:{counter:-1,key:b[1]},chainType:ChainType.SENDING});c.rootKey=b[0]}}module.exports=SessionBuilder;
