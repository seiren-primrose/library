const ChainType=require("./chain_type"),ProtocolAddress=require("./protocol_address"),SessionBuilder=require("./session_builder"),SessionRecord=require("./session_record"),cryptoS=require("./crypto"),curve=require("./curve"),errors=require("./errors"),protobufs=require("./protobufs"),queueJob=require("./queue_job"),VERSION=3;function assertBuffer(a){if(!(a instanceof Buffer))throw TypeError(`Expected Buffer instead of: ${a.constructor.name}`);return a}
class SessionCipher{constructor(a,d){if(!(d instanceof ProtocolAddress))throw new TypeError("protocolAddress must be a ProtocolAddress");this.addr=d;this.storage=a}_encodeTupleByte(a,d){if(15<a||15<d)throw TypeError("Numbers must be 4 bits or less");return a<<4|d}_decodeTupleByte(a){return[a>>4,a&15]}toString(){return`<SessionCipher(${this.addr.toString()})>`}async getRecord(){const a=await this.storage.loadSession(this.addr.toString());if(a&&!(a instanceof SessionRecord))throw new TypeError("SessionRecord type expected from loadSession");
return a}async storeRecord(a){a.removeOldSessions();await this.storage.storeSession(this.addr.toString(),a)}async queueJob(a){return await queueJob(this.addr.toString(),a)}async encrypt(a){assertBuffer(a);const d=await this.storage.getOurIdentity();return await this.queueJob(async()=>{var e=await this.getRecord();if(!e)throw new errors.SessionError("No sessions");const b=e.getOpenSession();if(!b)throw new errors.SessionError("No open session");var c=b.indexInfo.remoteIdentityKey;if(!await this.storage.isTrustedIdentity(this.addr.id,
c))throw new errors.UntrustedIdentityKeyError(this.addr.id,c);var f=b.getChain(b.currentRatchet.ephemeralKeyPair.pubKey);if(f.chainType===ChainType.RECEIVING)throw Error("Tried to encrypt on a receiving chain");this.fillMessageKeys(f,f.chainKey.counter+1);c=cryptoS.deriveSecrets(f.messageKeys[f.chainKey.counter],Buffer.alloc(32),Buffer.from("WhisperMessageKeys"));delete f.messageKeys[f.chainKey.counter];var g=protobufs.WhisperMessage.create();g.ephemeralKey=b.currentRatchet.ephemeralKeyPair.pubKey;
g.counter=f.chainKey.counter;g.previousCounter=b.currentRatchet.previousCounter;g.ciphertext=cryptoS.encrypt(c[0],a,c[2].slice(0,16));f=protobufs.WhisperMessage.encode(g).finish();g=Buffer.alloc(f.byteLength+66+1);g.set(d.pubKey);g.set(b.indexInfo.remoteIdentityKey,33);g[66]=this._encodeTupleByte(VERSION,VERSION);g.set(f,67);g=cryptoS.calculateMAC(c[1],g);c=Buffer.alloc(f.byteLength+9);c[0]=this._encodeTupleByte(VERSION,VERSION);c.set(f,1);c.set(g.slice(0,8),f.byteLength+1);await this.storeRecord(e);
b.pendingPreKey?(e=3,c=protobufs.PreKeyWhisperMessage.create({identityKey:d.pubKey,registrationId:await this.storage.getOurRegistrationId(),baseKey:b.pendingPreKey.baseKey,signedPreKeyId:b.pendingPreKey.signedKeyId,message:c}),b.pendingPreKey.preKeyId&&(c.preKeyId=b.pendingPreKey.preKeyId),c=Buffer.concat([Buffer.from([this._encodeTupleByte(VERSION,VERSION)]),Buffer.from(protobufs.PreKeyWhisperMessage.encode(c).finish())])):e=1;return{type:e,body:c,registrationId:b.registrationId}})}async decryptWithSessions(a,
d){if(!d.length)throw new errors.SessionError("No sessions available");const e=[];for(const b of d){let c;try{return c=await this.doDecryptWhisperMessage(a,b),b.indexInfo.used=Date.now(),{session:b,plaintext:c}}catch(f){e.push(f)}}console.error("Failed to decrypt message with any known session...");for(const b of e)console.error("Session error:"+b,b.stack);throw new errors.SessionError("No matching sessions found for message");}async decryptWhisperMessage(a){assertBuffer(a);return await this.queueJob(async()=>
{const d=await this.getRecord();if(!d)throw new errors.SessionError("No session record");const e=await this.decryptWithSessions(a,d.getSessions()),b=e.session.indexInfo.remoteIdentityKey;if(!await this.storage.isTrustedIdentity(this.addr.id,b))throw new errors.UntrustedIdentityKeyError(this.addr.id,b);d.isClosed(e.session)&&console.warn("Decrypted message with closed session.");await this.storeRecord(d);return e.plaintext})}async decryptPreKeyWhisperMessage(a){assertBuffer(a);const d=this._decodeTupleByte(a[0]);
if(3<d[1]||3>d[0])throw Error("Incompatible version number on PreKeyWhisperMessage");return await this.queueJob(async()=>{let e=await this.getRecord();var b=protobufs.PreKeyWhisperMessage.decode(a.slice(1));if(!e){if(null==b.registrationId)throw Error("No registrationId");e=new SessionRecord}const c=await (new SessionBuilder(this.storage,this.addr)).initIncoming(e,b),f=e.getSession(b.baseKey);b=await this.doDecryptWhisperMessage(b.message,f);await this.storeRecord(e);c&&await this.storage.removePreKey(c);
return b})}async doDecryptWhisperMessage(a,d){assertBuffer(a);if(!d)throw new TypeError("session required");var e=this._decodeTupleByte(a[0]);if(3<e[1]||3>e[0])throw Error("Incompatible version number on WhisperMessage");e=a.slice(1,-8);const b=protobufs.WhisperMessage.decode(e);this.maybeStepRatchet(d,b.ephemeralKey,b.previousCounter);var c=d.getChain(b.ephemeralKey);if(c.chainType===ChainType.SENDING)throw Error("Tried to decrypt on a sending chain");this.fillMessageKeys(c,b.counter);if(!c.messageKeys.hasOwnProperty(b.counter))throw new errors.MessageCounterError("Key used already or never filled");
var f=c.messageKeys[b.counter];delete c.messageKeys[b.counter];c=cryptoS.deriveSecrets(f,Buffer.alloc(32),Buffer.from("WhisperMessageKeys"));f=await this.storage.getOurIdentity();const g=Buffer.alloc(e.byteLength+66+1);g.set(d.indexInfo.remoteIdentityKey);g.set(f.pubKey,33);g[66]=this._encodeTupleByte(VERSION,VERSION);g.set(e,67);cryptoS.verifyMAC(g,c[1],a.slice(-8),8);a=cryptoS.decrypt(c[0],b.ciphertext,c[2].slice(0,16));delete d.pendingPreKey;return a}fillMessageKeys(a,d){if(!(a.chainKey.counter>=
d)){if(2E3<d-a.chainKey.counter)throw new errors.SessionError("Over 2000 messages into the future!");if(void 0===a.chainKey.key)throw new errors.SessionError("Chain closed");var e=a.chainKey.key;a.messageKeys[a.chainKey.counter+1]=cryptoS.calculateMAC(e,Buffer.from([1]));a.chainKey.key=cryptoS.calculateMAC(e,Buffer.from([2]));a.chainKey.counter+=1;return this.fillMessageKeys(a,d)}}maybeStepRatchet(a,d,e){if(!a.getChain(d)){var b=a.currentRatchet,c=a.getChain(b.lastRemoteEphemeralKey);c&&(this.fillMessageKeys(c,
e),delete c.chainKey.key);this.calculateRatchet(a,d,!1);if(e=a.getChain(b.ephemeralKeyPair.pubKey))b.previousCounter=e.chainKey.counter,a.deleteChain(b.ephemeralKeyPair.pubKey);b.ephemeralKeyPair=curve.generateKeyPair();this.calculateRatchet(a,d,!0);b.lastRemoteEphemeralKey=d}}calculateRatchet(a,d,e){let b=a.currentRatchet;var c=curve.calculateAgreement(d,b.ephemeralKeyPair.privKey);c=cryptoS.deriveSecrets(c,b.rootKey,Buffer.from("WhisperRatchet"),2);a.addChain(e?b.ephemeralKeyPair.pubKey:d,{messageKeys:{},
chainKey:{counter:-1,key:c[1]},chainType:e?ChainType.SENDING:ChainType.RECEIVING});b.rootKey=c[0]}async hasOpenSession(){return await this.queueJob(async()=>{const a=await this.getRecord();return a?a.haveOpenSession():!1})}async closeOpenSession(){return await this.queueJob(async()=>{const a=await this.getRecord();if(a){const d=a.getOpenSession();d&&(a.closeSession(d),await this.storeRecord(a))}})}}module.exports=SessionCipher;
