const curveJs=require("curve25519-js"),nodeCrypto=require("crypto"),PUBLIC_KEY_DER_PREFIX=Buffer.from([48,42,48,5,6,3,43,101,110,3,33,0]),PRIVATE_KEY_DER_PREFIX=Buffer.from([48,46,2,1,0,48,5,6,3,43,101,110,4,34,4,32]),KEY_BUNDLE_TYPE=Buffer.from([5]),prefixKeyInPublicKey=function(a){return Buffer.concat([KEY_BUNDLE_TYPE,a])};
function validatePrivKey(a){if(void 0===a)throw Error("Undefined private key");if(!(a instanceof Buffer))throw Error(`Invalid private key type: ${a.constructor.name}`);if(32!=a.byteLength)throw Error(`Incorrect private key length: ${a.byteLength}`);}
function scrubPubKeyFormat(a){if(!(a instanceof Buffer))throw Error(`Invalid public key type: ${a.constructor.name}`);if(void 0===a||(33!=a.byteLength||5!=a[0])&&32!=a.byteLength)throw Error("Invalid public key");if(33==a.byteLength)return a.slice(1);console.error("WARNING: Expected pubkey of length 33, please report the ST and client that generated the pubkey");return a}function unclampEd25519PrivateKey(a){a=new Uint8Array(a);a[0]|=6;a[31]|=128;a[31]&=-65;return a}
exports.getPublicFromPrivateKey=function(a){a=unclampEd25519PrivateKey(a);a=curveJs.generateKeyPair(a);return prefixKeyInPublicKey(Buffer.from(a.public))};
exports.generateKeyPair=function(){try{const {publicKey:b,privateKey:c}=nodeCrypto.generateKeyPairSync("x25519",{publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});var a=b.slice(PUBLIC_KEY_DER_PREFIX.length,PUBLIC_KEY_DER_PREFIX.length+32);const d=c.slice(PRIVATE_KEY_DER_PREFIX.length,PRIVATE_KEY_DER_PREFIX.length+32);return{pubKey:prefixKeyInPublicKey(a),privKey:d}}catch(b){return a=curveJs.generateKeyPair(nodeCrypto.randomBytes(32)),{privKey:Buffer.from(a.private),
pubKey:prefixKeyInPublicKey(Buffer.from(a.public))}}};
exports.calculateAgreement=function(a,b){a=scrubPubKeyFormat(a);validatePrivKey(b);if(!a||32!=a.byteLength)throw Error("Invalid public key");if("function"===typeof nodeCrypto.diffieHellman)return b=nodeCrypto.createPrivateKey({key:Buffer.concat([PRIVATE_KEY_DER_PREFIX,b]),format:"der",type:"pkcs8"}),a=nodeCrypto.createPublicKey({key:Buffer.concat([PUBLIC_KEY_DER_PREFIX,a]),format:"der",type:"spki"}),nodeCrypto.diffieHellman({privateKey:b,publicKey:a});a=curveJs.sharedKey(b,a);return Buffer.from(a)};
exports.calculateSignature=function(a,b){validatePrivKey(a);if(!b)throw Error("Invalid message");return Buffer.from(curveJs.sign(a,b))};exports.verifySignature=function(a,b,c,d){a=scrubPubKeyFormat(a);if(!a||32!=a.byteLength)throw Error("Invalid public key");if(!b)throw Error("Invalid message");if(!c||64!=c.byteLength)throw Error("Invalid signature");return d?!0:curveJs.verify(a,b,c)};
