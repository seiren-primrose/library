const cryptoS=require("./crypto.js");var VERSION=0;async function iterateHash(a,b,c){a=(new Uint8Array(Buffer.concat([a,b]))).buffer;a=cryptoS.hash(a);return 0===--c?a:iterateHash(a,b,c)}function shortToArrayBuffer(a){return(new Uint16Array([a])).buffer}function getEncodedChunk(a,b){for(a=((a[b]*Math.pow(2,32)+a[b+1]*Math.pow(2,24)+a[b+2]*Math.pow(2,16)+a[b+3]*Math.pow(2,8)+a[b+4])%1E5).toString();5>a.length;)a="0"+a;return a}
async function getDisplayStringFor(a,b,c){a=Buffer.concat([shortToArrayBuffer(VERSION),b,a]);a=(new Uint8Array(a)).buffer;b=new Uint8Array(await iterateHash(a,b,c));return getEncodedChunk(b,0)+getEncodedChunk(b,5)+getEncodedChunk(b,10)+getEncodedChunk(b,15)+getEncodedChunk(b,20)+getEncodedChunk(b,25)}exports.FingerprintGenerator=function(a){this.iterations=a};
exports.FingerprintGenerator.prototype={createFor:function(a,b,c,d){if(!("string"===typeof a&&"string"===typeof c&&b instanceof ArrayBuffer&&d instanceof ArrayBuffer))throw Error("Invalid arguments");return Promise.all([getDisplayStringFor(a,b,this.iterations),getDisplayStringFor(c,d,this.iterations)]).then(function(e){return e.sort().join("")})}};
